""" Timer_rule.

Do not edit this file by hand.
This is generated by parsing api.html service doc.
"""
from ambra_sdk.exceptions.service import FilterNotFound
from ambra_sdk.exceptions.service import InvalidCondition
from ambra_sdk.exceptions.service import InvalidField
from ambra_sdk.exceptions.service import InvalidInteger
from ambra_sdk.exceptions.service import InvalidSortField
from ambra_sdk.exceptions.service import InvalidSortOrder
from ambra_sdk.exceptions.service import InvalidValue
from ambra_sdk.exceptions.service import MissingFields
from ambra_sdk.exceptions.service import NamespaceNotFound
from ambra_sdk.exceptions.service import NotFound
from ambra_sdk.exceptions.service import NotHash
from ambra_sdk.exceptions.service import NotPermitted
from ambra_sdk.exceptions.service import UnsupportedStudyField
from ambra_sdk.exceptions.service import ValidationFailed
from ambra_sdk.service.query import QueryO
from ambra_sdk.service.query import AsyncQueryO
from ambra_sdk.service.query import QueryOPSF
from ambra_sdk.service.query import AsyncQueryOPSF

class Timer_rule:
    """Timer_rule."""

    def __init__(self, api):
        self._api = api

    
    def list(
        self,
        account_id,
    ):
        """List.

        :param account_id: uuid of the account
        """
        request_data = {
           'account_id': account_id,
        }
	
        errors_mapping = {}
        errors_mapping[('FILTER_NOT_FOUND', None)] = FilterNotFound('The filter can not be found. The error_subtype will hold the filter UUID')
        errors_mapping[('INVALID_CONDITION', None)] = InvalidCondition('The condition is not support. The error_subtype will hold the filter expression this applies to')
        errors_mapping[('INVALID_FIELD', None)] = InvalidField('The field is not valid for this object. The error_subtype will hold the filter expression this applies to')
        errors_mapping[('INVALID_SORT_FIELD', None)] = InvalidSortField('The field is not valid for this object. The error_subtype will hold the field name this applies to')
        errors_mapping[('INVALID_SORT_ORDER', None)] = InvalidSortOrder('The sort order for the field is invalid. The error_subtype will hold the field name this applies to')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The account can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to view timer rules in this account')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/list',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        query_data['paginated_field'] = 'timer_rules'
        return QueryOPSF(**query_data)
    
    def add(
        self,
        action,
        name,
        rule_set_id,
        new_values=None,
        old_values=None,
        sequence=None,
    ):
        """Add.

        :param action: The action to perform on rule match (reset|reset_and_stop|reset_and_resume|resume|stop|do_nothing)
        :param name: Name of the timer rule
        :param rule_set_id: uuid of the rule set to add them to
        :param new_values: JSON hash of the values to compare with the next study state. Keys correspond to study fields, each hash element is an ARRAY of actual values to use in comparison (optional)
        :param old_values: JSON hash of the values to compare with the previous study state. Keys correspond to study fields, each hash element is an ARRAY of actual values to use in comparison (optional)
        :param sequence: An integer value. Rules are processed from low number to high number (optional)
        """
        request_data = {
           'action': action,
           'name': name,
           'new_values': new_values,
           'old_values': old_values,
           'rule_set_id': rule_set_id,
           'sequence': sequence,
        }
	
        errors_mapping = {}
        errors_mapping[('INVALID_INTEGER', None)] = InvalidInteger('An invalid integer was passed. The error_subtype holds the name of the invalid integer')
        errors_mapping[('INVALID_VALUE', None)] = InvalidValue('The rule condition value is not an array')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NAMESPACE_NOT_FOUND', None)] = NamespaceNotFound('The namespace referred by the rule was not found')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The rule set can not be found')
        errors_mapping[('NOT_HASH', None)] = NotHash('The field is not a JSON hash. The error_subtype holds the name of the field')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to add a rule set to the account')
        errors_mapping[('UNSUPPORTED_STUDY_FIELD', None)] = UnsupportedStudyField('The referred study field is not supported')
        errors_mapping[('VALIDATION_FAILED', None)] = ValidationFailed('A field failed validation. The error_subtype holds the name of the invalid field')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/add',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def set(
        self,
        uuid,
        action=None,
        name=None,
        new_values=None,
        old_values=None,
        sequence=None,
    ):
        """Set.

        :param uuid: The timer rule uuid
        :param action: The action to perform on rule match (reset|reset_and_stop|reset_and_resume|resume|stop|do_nothing) (optional)
        :param name: Name of the timer rule (optional)
        :param new_values: JSON hash of the values to compare with the next study state. Keys correspond to study fields, each hash element is an ARRAY of actual values to use in comparison (optional)
        :param old_values: JSON hash of the values to compare with the previous study state. Keys correspond to study fields, each hash element is an ARRAY of actual values to use in comparison (optional)
        :param sequence: An integer value. Rules are processed from low number to high number (optional)
        """
        request_data = {
           'action': action,
           'name': name,
           'new_values': new_values,
           'old_values': old_values,
           'sequence': sequence,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('INVALID_INTEGER', None)] = InvalidInteger('An invalid integer was passed. The error_subtype holds the name of the invalid integer')
        errors_mapping[('INVALID_VALUE', None)] = InvalidValue('The rule condition value is not an array')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NAMESPACE_NOT_FOUND', None)] = NamespaceNotFound('The namespace referred by the rule was not found')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The timer rule was not found')
        errors_mapping[('NOT_HASH', None)] = NotHash('The field is not a JSON hash. The error_subtype holds the name of the field')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to edit the timer rule')
        errors_mapping[('UNSUPPORTED_STUDY_FIELD', None)] = UnsupportedStudyField('The referred study field is not supported')
        errors_mapping[('VALIDATION_FAILED', None)] = ValidationFailed('A field failed validation. The error_subtype holds the name of the invalid field')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/set',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def get(
        self,
        uuid,
    ):
        """Get.

        :param uuid: The timer rule uuid
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The timer rule can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to view the timer rule')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/get',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def delete(
        self,
        uuid,
    ):
        """Delete.

        :param uuid: The timer rule uuid
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The timer rule can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to delete the timer rule')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/delete',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    


class AsyncTimer_rule:
    """AsyncTimer_rule."""

    def __init__(self, api):
        self._api = api

    
    def list(
        self,
        account_id,
    ):
        """List.

        :param account_id: uuid of the account
        """
        request_data = {
           'account_id': account_id,
        }
	
        errors_mapping = {}
        errors_mapping[('FILTER_NOT_FOUND', None)] = FilterNotFound('The filter can not be found. The error_subtype will hold the filter UUID')
        errors_mapping[('INVALID_CONDITION', None)] = InvalidCondition('The condition is not support. The error_subtype will hold the filter expression this applies to')
        errors_mapping[('INVALID_FIELD', None)] = InvalidField('The field is not valid for this object. The error_subtype will hold the filter expression this applies to')
        errors_mapping[('INVALID_SORT_FIELD', None)] = InvalidSortField('The field is not valid for this object. The error_subtype will hold the field name this applies to')
        errors_mapping[('INVALID_SORT_ORDER', None)] = InvalidSortOrder('The sort order for the field is invalid. The error_subtype will hold the field name this applies to')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The account can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to view timer rules in this account')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/list',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        query_data['paginated_field'] = 'timer_rules'
        return AsyncQueryOPSF(**query_data)
    
    def add(
        self,
        action,
        name,
        rule_set_id,
        new_values=None,
        old_values=None,
        sequence=None,
    ):
        """Add.

        :param action: The action to perform on rule match (reset|reset_and_stop|reset_and_resume|resume|stop|do_nothing)
        :param name: Name of the timer rule
        :param rule_set_id: uuid of the rule set to add them to
        :param new_values: JSON hash of the values to compare with the next study state. Keys correspond to study fields, each hash element is an ARRAY of actual values to use in comparison (optional)
        :param old_values: JSON hash of the values to compare with the previous study state. Keys correspond to study fields, each hash element is an ARRAY of actual values to use in comparison (optional)
        :param sequence: An integer value. Rules are processed from low number to high number (optional)
        """
        request_data = {
           'action': action,
           'name': name,
           'new_values': new_values,
           'old_values': old_values,
           'rule_set_id': rule_set_id,
           'sequence': sequence,
        }
	
        errors_mapping = {}
        errors_mapping[('INVALID_INTEGER', None)] = InvalidInteger('An invalid integer was passed. The error_subtype holds the name of the invalid integer')
        errors_mapping[('INVALID_VALUE', None)] = InvalidValue('The rule condition value is not an array')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NAMESPACE_NOT_FOUND', None)] = NamespaceNotFound('The namespace referred by the rule was not found')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The rule set can not be found')
        errors_mapping[('NOT_HASH', None)] = NotHash('The field is not a JSON hash. The error_subtype holds the name of the field')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to add a rule set to the account')
        errors_mapping[('UNSUPPORTED_STUDY_FIELD', None)] = UnsupportedStudyField('The referred study field is not supported')
        errors_mapping[('VALIDATION_FAILED', None)] = ValidationFailed('A field failed validation. The error_subtype holds the name of the invalid field')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/add',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def set(
        self,
        uuid,
        action=None,
        name=None,
        new_values=None,
        old_values=None,
        sequence=None,
    ):
        """Set.

        :param uuid: The timer rule uuid
        :param action: The action to perform on rule match (reset|reset_and_stop|reset_and_resume|resume|stop|do_nothing) (optional)
        :param name: Name of the timer rule (optional)
        :param new_values: JSON hash of the values to compare with the next study state. Keys correspond to study fields, each hash element is an ARRAY of actual values to use in comparison (optional)
        :param old_values: JSON hash of the values to compare with the previous study state. Keys correspond to study fields, each hash element is an ARRAY of actual values to use in comparison (optional)
        :param sequence: An integer value. Rules are processed from low number to high number (optional)
        """
        request_data = {
           'action': action,
           'name': name,
           'new_values': new_values,
           'old_values': old_values,
           'sequence': sequence,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('INVALID_INTEGER', None)] = InvalidInteger('An invalid integer was passed. The error_subtype holds the name of the invalid integer')
        errors_mapping[('INVALID_VALUE', None)] = InvalidValue('The rule condition value is not an array')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NAMESPACE_NOT_FOUND', None)] = NamespaceNotFound('The namespace referred by the rule was not found')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The timer rule was not found')
        errors_mapping[('NOT_HASH', None)] = NotHash('The field is not a JSON hash. The error_subtype holds the name of the field')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to edit the timer rule')
        errors_mapping[('UNSUPPORTED_STUDY_FIELD', None)] = UnsupportedStudyField('The referred study field is not supported')
        errors_mapping[('VALIDATION_FAILED', None)] = ValidationFailed('A field failed validation. The error_subtype holds the name of the invalid field')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/set',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def get(
        self,
        uuid,
    ):
        """Get.

        :param uuid: The timer rule uuid
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The timer rule can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to view the timer rule')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/get',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def delete(
        self,
        uuid,
    ):
        """Delete.

        :param uuid: The timer rule uuid
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The timer rule can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to delete the timer rule')
        query_data = {
            'api': self._api,
            'url': '/timer_rule/delete',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
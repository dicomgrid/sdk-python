""" Customfield.

Do not edit this file by hand.
This is generated by parsing api.html service doc.
"""
from ambra_sdk.exceptions.service import AccountNotFound
from ambra_sdk.exceptions.service import AlreadyExists
from ambra_sdk.exceptions.service import FilterNotFound
from ambra_sdk.exceptions.service import InvalidCondition
from ambra_sdk.exceptions.service import InvalidDicomTag
from ambra_sdk.exceptions.service import InvalidDicomTagObject
from ambra_sdk.exceptions.service import InvalidField
from ambra_sdk.exceptions.service import InvalidFlag
from ambra_sdk.exceptions.service import InvalidHl7Field
from ambra_sdk.exceptions.service import InvalidHl7Object
from ambra_sdk.exceptions.service import InvalidHl7Segment
from ambra_sdk.exceptions.service import InvalidInteger
from ambra_sdk.exceptions.service import InvalidJson
from ambra_sdk.exceptions.service import InvalidObject
from ambra_sdk.exceptions.service import InvalidOptions
from ambra_sdk.exceptions.service import InvalidSearchSource
from ambra_sdk.exceptions.service import InvalidSortField
from ambra_sdk.exceptions.service import InvalidSortOrder
from ambra_sdk.exceptions.service import InvalidType
from ambra_sdk.exceptions.service import MissingFields
from ambra_sdk.exceptions.service import NoDicomTagDefined
from ambra_sdk.exceptions.service import NotASearch
from ambra_sdk.exceptions.service import NotFound
from ambra_sdk.exceptions.service import NotPermitted
from ambra_sdk.service.query import QueryO
from ambra_sdk.service.query import AsyncQueryO
from ambra_sdk.service.query import QueryOPSF
from ambra_sdk.service.query import AsyncQueryOPSF

class Customfield:
    """Customfield."""

    def __init__(self, api):
        self._api = api

    
    def list(
        self,
        account_id,
    ):
        """List.

        :param account_id: uuid of the account
        """
        request_data = {
           'account_id': account_id,
        }
	
        errors_mapping = {}
        errors_mapping[('FILTER_NOT_FOUND', None)] = FilterNotFound('The filter can not be found. The error_subtype will hold the filter UUID')
        errors_mapping[('INVALID_CONDITION', None)] = InvalidCondition('The condition is not support. The error_subtype will hold the filter expression this applies to')
        errors_mapping[('INVALID_FIELD', None)] = InvalidField('The field is not valid for this object. The error_subtype will hold the filter expression this applies to')
        errors_mapping[('INVALID_SORT_FIELD', None)] = InvalidSortField('The field is not valid for this object. The error_subtype will hold the field name this applies to')
        errors_mapping[('INVALID_SORT_ORDER', None)] = InvalidSortOrder('The sort order for the field is invalid. The error_subtype will hold the field name this applies to')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The account can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to view this list')
        query_data = {
            'api': self._api,
            'url': '/customfield/list',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        query_data['paginated_field'] = 'customfields'
        return QueryOPSF(**query_data)
    
    def add(
        self,
        account_id,
        name,
        object,
        capture_on_destination_search=None,
        capture_on_share_code=None,
        dicom_only=None,
        dicom_tag=None,
        dicom_tag_ignore_empty=None,
        display_order=None,
        field_flag=None,
        hl7_component=None,
        hl7_field=None,
        hl7_segment=None,
        load_dicom_tag=None,
        load_from_sr=None,
        load_hl7=None,
        load_hl7_filter=None,
        load_order=None,
        options=None,
        other_customfield_id=None,
        other_dicom_tags=None,
        required=None,
        type=None,
        wrapped_dicom_only=None,
    ):
        """Add.

        :param account_id: uuid of the account
        :param name: Name of the customfield
        :param object: The object to associate the customfield with (Study|User_account|Group|Location|Account|Patient|Case|Order|Appointment|Dicomdata|Scanner|Query)
        :param capture_on_destination_search: Flag if the field should be captured during query retrieve on /destination/search call (only applicable to study fields) (optional)
        :param capture_on_share_code: Flag if the field should be captured during a share code exchange (only applicable to study fields) (optional)
        :param dicom_only: Only capture for non-wrapped DICOM uploads during a share code exchange (optional)
        :param dicom_tag: DICOM tag to map this field to. Format should be of form (1234,1234). (only applicable to study fields) (optional)
        :param dicom_tag_ignore_empty: Flag to not map an empty custom field to the DICOM tag. (only applicable if a dicom_tag is specified) (optional)
        :param display_order: Integer to order how the fields should be displayed (optional)
        :param field_flag: Default customfield flag (optional)
        :param hl7_component: Component number to map this field to in HL7 ORM messages. Valid values are 1 to 64. (only applicable to study fields) (optional)
        :param hl7_field: Segment field number to map this field to in HL7 ORM messages. Valid values are 1 to 64. (only applicable to study fields) (optional)
        :param hl7_segment: Segment to map this field to in HL7 ORM messages. Valid values are (NTE|PID|PID1|PV1|PV2|OBR|DG1|OBX|CTI|BLG|ORC) (only applicable to study fields) (optional)
        :param load_dicom_tag: Flag to load the current value from the study into this field. (only applicable if a dicom_tag is specified) (optional)
        :param load_from_sr: Load the value from the structured reports in the study (only applicable to study fields) .(optional)
        :param load_hl7: If this is set to a HL7 message type the value of this field will be updated from the hl7_segment, hl7_field and hl7_component from incoming HL7 messages of the matching message type (only applicable to study fields) (optional)
        :param load_hl7_filter: Filter token for the load_hl7 option (only applicable to study fields) (optional)
        :param load_order: If this flag is on the value of this field will be loaded from a customfield of the matching Order. The customfield is defined by the other_customfield_id parameter (optional)
        :param options: Additional options in JSON format (optional)
        :param other_customfield_id: Id of a customfield to map its value to this customfield's value (optional)
        :param other_dicom_tags: JSON array of other DICOM tags to map this field to. (only applicable to study fields) (optional)
        :param required: Flag if the field is required (optional)
        :param type: Type of the custom field (text|number|date|memo|select|multiselect|radio|checkbox|search|bool) (optional)
        :param wrapped_dicom_only: Only capture for wrapped DICOM uploads during a share code exchange (optional)
        """
        request_data = {
           'account_id': account_id,
           'capture_on_destination_search': capture_on_destination_search,
           'capture_on_share_code': capture_on_share_code,
           'dicom_only': dicom_only,
           'dicom_tag': dicom_tag,
           'dicom_tag_ignore_empty': dicom_tag_ignore_empty,
           'display_order': display_order,
           'field_flag': field_flag,
           'hl7_component': hl7_component,
           'hl7_field': hl7_field,
           'hl7_segment': hl7_segment,
           'load_dicom_tag': load_dicom_tag,
           'load_from_sr': load_from_sr,
           'load_hl7': load_hl7,
           'load_hl7_filter': load_hl7_filter,
           'load_order': load_order,
           'name': name,
           'object': object,
           'options': options,
           'other_customfield_id': other_customfield_id,
           'other_dicom_tags': other_dicom_tags,
           'required': required,
           'type': type,
           'wrapped_dicom_only': wrapped_dicom_only,
        }
	
        errors_mapping = {}
        errors_mapping[('ACCOUNT_NOT_FOUND', None)] = AccountNotFound('The account can not be found')
        errors_mapping[('INVALID_DICOM_TAG', None)] = InvalidDicomTag('The DICOM tag is invalid')
        errors_mapping[('INVALID_DICOM_TAG_OBJECT', None)] = InvalidDicomTagObject('DICOM tags can only be applied to study fields')
        errors_mapping[('INVALID_FLAG', None)] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping[('INVALID_HL7_OBJECT', None)] = InvalidHl7Object('HL7 fields can only be applied to study fields')
        errors_mapping[('INVALID_HL7_SEGMENT', None)] = InvalidHl7Segment('Invalid segment name')
        errors_mapping[('INVALID_INTEGER', None)] = InvalidInteger('Invalid integer. The error_subtype holds the invalid integer.')
        errors_mapping[('INVALID_JSON', None)] = InvalidJson('The field is not in valid JSON format. The error_subtype holds the name of the field')
        errors_mapping[('INVALID_OBJECT', None)] = InvalidObject('An invalid object was passed.')
        errors_mapping[('INVALID_OPTIONS', None)] = InvalidOptions('An option is invalid. The error_subtype holds the specific error message')
        errors_mapping[('INVALID_SEARCH_SOURCE', None)] = InvalidSearchSource('An invalid search source was passed.')
        errors_mapping[('INVALID_TYPE', None)] = InvalidType('An invalid type was passed.')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The Customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to add a customfield to this account')
        errors_mapping[('NO_DICOM_TAG_DEFINED', None)] = NoDicomTagDefined('The load_dicom_tag flag is set but the dicom_tag field is not defined')
        query_data = {
            'api': self._api,
            'url': '/customfield/add',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def set(
        self,
        uuid,
        capture_on_destination_search=None,
        capture_on_share_code=None,
        dicom_only=None,
        dicom_tag=None,
        dicom_tag_ignore_empty=None,
        display_order=None,
        field_flag=None,
        hl7_component=None,
        hl7_field=None,
        hl7_segment=None,
        load_dicom_tag=None,
        load_from_sr=None,
        load_hl7=None,
        load_hl7_filter=None,
        load_order=None,
        name=None,
        options=None,
        other_customfield_id=None,
        other_customfield_no_overwrite_with_blank=None,
        other_customfield_no_refresh_on_reshare=None,
        other_dicom_tags=None,
        required=None,
        wrapped_dicom_only=None,
    ):
        """Set.

        :param uuid: uuid of the customfield
        :param capture_on_destination_search: Flag if the field should be captured during query retrieve on /destination/search call (optional)
        :param capture_on_share_code: Flag if the study type field should be captured during a share code exchange (optional)
        :param dicom_only: Only capture for non-wrapped DICOM uploads during a share code exchange (optional)
        :param dicom_tag: Dicom tag to map this field to. Format should be of form (1234,1234). (only applicable to study fields) (optional)
        :param dicom_tag_ignore_empty: Flag to not map an empty custom field to the DICOM tag. (only applicable if a dicom_tag is specified) (optional)
        :param display_order: Integer to order how the fields should be displayed (optional)
        :param field_flag: Default customfield flag (optional)
        :param hl7_component: Component number to map this field to in HL7 ORM messages. Valid values are 1 to 64. (only applicable to study fields) (optional)
        :param hl7_field: Segment field number to map this field to in HL7 ORM messages. Valid values are 1 to 64. (only applicable to study fields) (optional)
        :param hl7_segment: Segment to map this field to in HL7 ORM messages. Valid values are (NTE|PID|PID1|PV1|PV2|OBR|DG1|OBX|CTI|BLG|ORC) (only applicable to study fields) (optional)
        :param load_dicom_tag: Flag to load the current value from the study into this field. (only applicable if a dicom_tag is specified) (optional)
        :param load_from_sr: Load the value from the structured reports in the study. (only applicable to study fields) .(optional)
        :param load_hl7: If this is set to a HL7 message type the value of this field will be updated from the hl7_segment, hl7_field and hl7_component from incoming HL7 messages of the matching message type (only applicable to study fields) (optional)
        :param load_hl7_filter: Filter token for the load_hl7 option (only applicable to study fields) (optional)
        :param load_order: If this flag is on the value of this field will be loaded from a customfield of the matching Order. The customfield is defined by the other_customfield_id parameter (optional)
        :param name: Name of the customfield (optional)
        :param options: Additional options in JSON format (optional)
        :param other_customfield_id: Id of a customfield to map its value to this customfield's value (optional)
        :param other_customfield_no_overwrite_with_blank: Flag if the customfield should be updated with a blank value (optional)
        :param other_customfield_no_refresh_on_reshare: Flag if the customfield should be updated on Study reshare (optional)
        :param other_dicom_tags: JSON array of other DICOM tags to map this field to. (only applicable to study fields) (optional)
        :param required: Flag if the field is required (optional)
        :param wrapped_dicom_only: Only capture for wrapped DICOM uploads during a share code exchange (optional)
        """
        request_data = {
           'capture_on_destination_search': capture_on_destination_search,
           'capture_on_share_code': capture_on_share_code,
           'dicom_only': dicom_only,
           'dicom_tag': dicom_tag,
           'dicom_tag_ignore_empty': dicom_tag_ignore_empty,
           'display_order': display_order,
           'field_flag': field_flag,
           'hl7_component': hl7_component,
           'hl7_field': hl7_field,
           'hl7_segment': hl7_segment,
           'load_dicom_tag': load_dicom_tag,
           'load_from_sr': load_from_sr,
           'load_hl7': load_hl7,
           'load_hl7_filter': load_hl7_filter,
           'load_order': load_order,
           'name': name,
           'options': options,
           'other_customfield_id': other_customfield_id,
           'other_customfield_no_overwrite_with_blank': other_customfield_no_overwrite_with_blank,
           'other_customfield_no_refresh_on_reshare': other_customfield_no_refresh_on_reshare,
           'other_dicom_tags': other_dicom_tags,
           'required': required,
           'uuid': uuid,
           'wrapped_dicom_only': wrapped_dicom_only,
        }
	
        errors_mapping = {}
        errors_mapping[('INVALID_DICOM_TAG', None)] = InvalidDicomTag('The DICOM tag is invalid')
        errors_mapping[('INVALID_DICOM_TAG_OBJECT', None)] = InvalidDicomTagObject('DICOM tags can only be applied to study fields')
        errors_mapping[('INVALID_FLAG', None)] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping[('INVALID_HL7_FIELD', None)] = InvalidHl7Field('Invalid field number')
        errors_mapping[('INVALID_HL7_OBJECT', None)] = InvalidHl7Object('HL7 fields can only be applied to study fields')
        errors_mapping[('INVALID_HL7_SEGMENT', None)] = InvalidHl7Segment('Invalid segment name')
        errors_mapping[('INVALID_INTEGER', None)] = InvalidInteger('Invalid integer. The error_subtype holds the invalid integer.')
        errors_mapping[('INVALID_JSON', None)] = InvalidJson('The field is not in valid JSON format. The error_subtype holds the name of the field')
        errors_mapping[('INVALID_OPTIONS', None)] = InvalidOptions('An option is invalid. The error_subtype holds the specific error message')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The object was not found. The error_subtype holds the name of the key for the object that can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to edit the customfield')
        errors_mapping[('NO_DICOM_TAG_DEFINED', None)] = NoDicomTagDefined('The load_dicom_tag flag is set but the dicom_tag field is not defined')
        query_data = {
            'api': self._api,
            'url': '/customfield/set',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def get(
        self,
        uuid,
    ):
        """Get.

        :param uuid: uuid of the customfield
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to view the customfield')
        query_data = {
            'api': self._api,
            'url': '/customfield/get',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def delete(
        self,
        uuid,
    ):
        """Delete.

        :param uuid: uuid of the customfield
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to delete the customfield')
        query_data = {
            'api': self._api,
            'url': '/customfield/delete',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def lookup(
        self,
        account_id,
        name,
    ):
        """Lookup.

        :param account_id: uuid of the account
        :param name: Name of the customfield
        """
        request_data = {
           'account_id': account_id,
           'name': name,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/lookup',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def search(
        self,
        uuid,
        search=None,
    ):
        """Search.

        :param uuid: uuid of the customfield
        :param search: The value to search for (optional)
        """
        request_data = {
           'search': search,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_A_SEARCH', None)] = NotASearch('This is not a search type of customfield')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/search',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def mapping_add(
        self,
        from_customfield_id,
        to_customfield_id,
        overwrite_with_blank=None,
        refresh_on_edit=None,
        refresh_on_reshare=None,
        reverse_refresh_on_edit=None,
    ):
        """Mapping add.

        :param from_customfield_id: The source custom field id
        :param to_customfield_id: The destination custom field id
        :param overwrite_with_blank: Flag if the destination customfield should be updated with a blank value, 1 by default (optional)
        :param refresh_on_edit: Flag if the destination customfield should be updated on the source customfield edit, 1 by default (optional)
        :param refresh_on_reshare: Flag if the destination customfield should be updated on Study reshare, 1 by default (optional)
        :param reverse_refresh_on_edit: Flag if the mapping should apply in reverse, ie to the customfield designated as a from_customfield_id of the original study when a shared version of the study is edited, 0 by default (optional)
        """
        request_data = {
           'from_customfield_id': from_customfield_id,
           'overwrite_with_blank': overwrite_with_blank,
           'refresh_on_edit': refresh_on_edit,
           'refresh_on_reshare': refresh_on_reshare,
           'reverse_refresh_on_edit': reverse_refresh_on_edit,
           'to_customfield_id': to_customfield_id,
        }
	
        errors_mapping = {}
        errors_mapping[('ALREADY_EXISTS', None)] = AlreadyExists('The mapping rule already exists')
        errors_mapping[('INVALID_FLAG', None)] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found, The error_subtype refers to a customfield by the following values: FROM_CUSTOMFIELD or TO_CUSTOMFIELD')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/mapping/add',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def mapping_set(
        self,
        uuid,
        overwrite_with_blank=None,
        refresh_on_edit=None,
        refresh_on_reshare=None,
        reverse_refresh_on_edit=None,
    ):
        """Mapping set.

        :param uuid: uuid of the customfield mapping rule
        :param overwrite_with_blank: Flag if the destination customfield should be updated with a blank value, 1 by default (optional)
        :param refresh_on_edit: Flag if the destination customfield should be updated on the source customfield edit, 1 by default (optional)
        :param refresh_on_reshare: Flag if the destination customfield should be updated on Study reshare, 1 by default (optional)
        :param reverse_refresh_on_edit: Flag if the mapping should apply in reverse, ie to the customfield designated as a from_customfield_id of the original study when a shared version of the study is edited, 0 by default (optional)
        """
        request_data = {
           'overwrite_with_blank': overwrite_with_blank,
           'refresh_on_edit': refresh_on_edit,
           'refresh_on_reshare': refresh_on_reshare,
           'reverse_refresh_on_edit': reverse_refresh_on_edit,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('INVALID_FLAG', None)] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield mapping rule can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/mapping/set',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def mapping_delete(
        self,
        uuid,
    ):
        """Mapping delete.

        :param uuid: uuid of the customfield mapping rule
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield mapping rule can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/mapping/delete',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    


class AsyncCustomfield:
    """AsyncCustomfield."""

    def __init__(self, api):
        self._api = api

    
    def list(
        self,
        account_id,
    ):
        """List.

        :param account_id: uuid of the account
        """
        request_data = {
           'account_id': account_id,
        }
	
        errors_mapping = {}
        errors_mapping[('FILTER_NOT_FOUND', None)] = FilterNotFound('The filter can not be found. The error_subtype will hold the filter UUID')
        errors_mapping[('INVALID_CONDITION', None)] = InvalidCondition('The condition is not support. The error_subtype will hold the filter expression this applies to')
        errors_mapping[('INVALID_FIELD', None)] = InvalidField('The field is not valid for this object. The error_subtype will hold the filter expression this applies to')
        errors_mapping[('INVALID_SORT_FIELD', None)] = InvalidSortField('The field is not valid for this object. The error_subtype will hold the field name this applies to')
        errors_mapping[('INVALID_SORT_ORDER', None)] = InvalidSortOrder('The sort order for the field is invalid. The error_subtype will hold the field name this applies to')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The account can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to view this list')
        query_data = {
            'api': self._api,
            'url': '/customfield/list',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        query_data['paginated_field'] = 'customfields'
        return AsyncQueryOPSF(**query_data)
    
    def add(
        self,
        account_id,
        name,
        object,
        capture_on_destination_search=None,
        capture_on_share_code=None,
        dicom_only=None,
        dicom_tag=None,
        dicom_tag_ignore_empty=None,
        display_order=None,
        field_flag=None,
        hl7_component=None,
        hl7_field=None,
        hl7_segment=None,
        load_dicom_tag=None,
        load_from_sr=None,
        load_hl7=None,
        load_hl7_filter=None,
        load_order=None,
        options=None,
        other_customfield_id=None,
        other_dicom_tags=None,
        required=None,
        type=None,
        wrapped_dicom_only=None,
    ):
        """Add.

        :param account_id: uuid of the account
        :param name: Name of the customfield
        :param object: The object to associate the customfield with (Study|User_account|Group|Location|Account|Patient|Case|Order|Appointment|Dicomdata|Scanner|Query)
        :param capture_on_destination_search: Flag if the field should be captured during query retrieve on /destination/search call (only applicable to study fields) (optional)
        :param capture_on_share_code: Flag if the field should be captured during a share code exchange (only applicable to study fields) (optional)
        :param dicom_only: Only capture for non-wrapped DICOM uploads during a share code exchange (optional)
        :param dicom_tag: DICOM tag to map this field to. Format should be of form (1234,1234). (only applicable to study fields) (optional)
        :param dicom_tag_ignore_empty: Flag to not map an empty custom field to the DICOM tag. (only applicable if a dicom_tag is specified) (optional)
        :param display_order: Integer to order how the fields should be displayed (optional)
        :param field_flag: Default customfield flag (optional)
        :param hl7_component: Component number to map this field to in HL7 ORM messages. Valid values are 1 to 64. (only applicable to study fields) (optional)
        :param hl7_field: Segment field number to map this field to in HL7 ORM messages. Valid values are 1 to 64. (only applicable to study fields) (optional)
        :param hl7_segment: Segment to map this field to in HL7 ORM messages. Valid values are (NTE|PID|PID1|PV1|PV2|OBR|DG1|OBX|CTI|BLG|ORC) (only applicable to study fields) (optional)
        :param load_dicom_tag: Flag to load the current value from the study into this field. (only applicable if a dicom_tag is specified) (optional)
        :param load_from_sr: Load the value from the structured reports in the study (only applicable to study fields) .(optional)
        :param load_hl7: If this is set to a HL7 message type the value of this field will be updated from the hl7_segment, hl7_field and hl7_component from incoming HL7 messages of the matching message type (only applicable to study fields) (optional)
        :param load_hl7_filter: Filter token for the load_hl7 option (only applicable to study fields) (optional)
        :param load_order: If this flag is on the value of this field will be loaded from a customfield of the matching Order. The customfield is defined by the other_customfield_id parameter (optional)
        :param options: Additional options in JSON format (optional)
        :param other_customfield_id: Id of a customfield to map its value to this customfield's value (optional)
        :param other_dicom_tags: JSON array of other DICOM tags to map this field to. (only applicable to study fields) (optional)
        :param required: Flag if the field is required (optional)
        :param type: Type of the custom field (text|number|date|memo|select|multiselect|radio|checkbox|search|bool) (optional)
        :param wrapped_dicom_only: Only capture for wrapped DICOM uploads during a share code exchange (optional)
        """
        request_data = {
           'account_id': account_id,
           'capture_on_destination_search': capture_on_destination_search,
           'capture_on_share_code': capture_on_share_code,
           'dicom_only': dicom_only,
           'dicom_tag': dicom_tag,
           'dicom_tag_ignore_empty': dicom_tag_ignore_empty,
           'display_order': display_order,
           'field_flag': field_flag,
           'hl7_component': hl7_component,
           'hl7_field': hl7_field,
           'hl7_segment': hl7_segment,
           'load_dicom_tag': load_dicom_tag,
           'load_from_sr': load_from_sr,
           'load_hl7': load_hl7,
           'load_hl7_filter': load_hl7_filter,
           'load_order': load_order,
           'name': name,
           'object': object,
           'options': options,
           'other_customfield_id': other_customfield_id,
           'other_dicom_tags': other_dicom_tags,
           'required': required,
           'type': type,
           'wrapped_dicom_only': wrapped_dicom_only,
        }
	
        errors_mapping = {}
        errors_mapping[('ACCOUNT_NOT_FOUND', None)] = AccountNotFound('The account can not be found')
        errors_mapping[('INVALID_DICOM_TAG', None)] = InvalidDicomTag('The DICOM tag is invalid')
        errors_mapping[('INVALID_DICOM_TAG_OBJECT', None)] = InvalidDicomTagObject('DICOM tags can only be applied to study fields')
        errors_mapping[('INVALID_FLAG', None)] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping[('INVALID_HL7_OBJECT', None)] = InvalidHl7Object('HL7 fields can only be applied to study fields')
        errors_mapping[('INVALID_HL7_SEGMENT', None)] = InvalidHl7Segment('Invalid segment name')
        errors_mapping[('INVALID_INTEGER', None)] = InvalidInteger('Invalid integer. The error_subtype holds the invalid integer.')
        errors_mapping[('INVALID_JSON', None)] = InvalidJson('The field is not in valid JSON format. The error_subtype holds the name of the field')
        errors_mapping[('INVALID_OBJECT', None)] = InvalidObject('An invalid object was passed.')
        errors_mapping[('INVALID_OPTIONS', None)] = InvalidOptions('An option is invalid. The error_subtype holds the specific error message')
        errors_mapping[('INVALID_SEARCH_SOURCE', None)] = InvalidSearchSource('An invalid search source was passed.')
        errors_mapping[('INVALID_TYPE', None)] = InvalidType('An invalid type was passed.')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The Customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to add a customfield to this account')
        errors_mapping[('NO_DICOM_TAG_DEFINED', None)] = NoDicomTagDefined('The load_dicom_tag flag is set but the dicom_tag field is not defined')
        query_data = {
            'api': self._api,
            'url': '/customfield/add',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def set(
        self,
        uuid,
        capture_on_destination_search=None,
        capture_on_share_code=None,
        dicom_only=None,
        dicom_tag=None,
        dicom_tag_ignore_empty=None,
        display_order=None,
        field_flag=None,
        hl7_component=None,
        hl7_field=None,
        hl7_segment=None,
        load_dicom_tag=None,
        load_from_sr=None,
        load_hl7=None,
        load_hl7_filter=None,
        load_order=None,
        name=None,
        options=None,
        other_customfield_id=None,
        other_customfield_no_overwrite_with_blank=None,
        other_customfield_no_refresh_on_reshare=None,
        other_dicom_tags=None,
        required=None,
        wrapped_dicom_only=None,
    ):
        """Set.

        :param uuid: uuid of the customfield
        :param capture_on_destination_search: Flag if the field should be captured during query retrieve on /destination/search call (optional)
        :param capture_on_share_code: Flag if the study type field should be captured during a share code exchange (optional)
        :param dicom_only: Only capture for non-wrapped DICOM uploads during a share code exchange (optional)
        :param dicom_tag: Dicom tag to map this field to. Format should be of form (1234,1234). (only applicable to study fields) (optional)
        :param dicom_tag_ignore_empty: Flag to not map an empty custom field to the DICOM tag. (only applicable if a dicom_tag is specified) (optional)
        :param display_order: Integer to order how the fields should be displayed (optional)
        :param field_flag: Default customfield flag (optional)
        :param hl7_component: Component number to map this field to in HL7 ORM messages. Valid values are 1 to 64. (only applicable to study fields) (optional)
        :param hl7_field: Segment field number to map this field to in HL7 ORM messages. Valid values are 1 to 64. (only applicable to study fields) (optional)
        :param hl7_segment: Segment to map this field to in HL7 ORM messages. Valid values are (NTE|PID|PID1|PV1|PV2|OBR|DG1|OBX|CTI|BLG|ORC) (only applicable to study fields) (optional)
        :param load_dicom_tag: Flag to load the current value from the study into this field. (only applicable if a dicom_tag is specified) (optional)
        :param load_from_sr: Load the value from the structured reports in the study. (only applicable to study fields) .(optional)
        :param load_hl7: If this is set to a HL7 message type the value of this field will be updated from the hl7_segment, hl7_field and hl7_component from incoming HL7 messages of the matching message type (only applicable to study fields) (optional)
        :param load_hl7_filter: Filter token for the load_hl7 option (only applicable to study fields) (optional)
        :param load_order: If this flag is on the value of this field will be loaded from a customfield of the matching Order. The customfield is defined by the other_customfield_id parameter (optional)
        :param name: Name of the customfield (optional)
        :param options: Additional options in JSON format (optional)
        :param other_customfield_id: Id of a customfield to map its value to this customfield's value (optional)
        :param other_customfield_no_overwrite_with_blank: Flag if the customfield should be updated with a blank value (optional)
        :param other_customfield_no_refresh_on_reshare: Flag if the customfield should be updated on Study reshare (optional)
        :param other_dicom_tags: JSON array of other DICOM tags to map this field to. (only applicable to study fields) (optional)
        :param required: Flag if the field is required (optional)
        :param wrapped_dicom_only: Only capture for wrapped DICOM uploads during a share code exchange (optional)
        """
        request_data = {
           'capture_on_destination_search': capture_on_destination_search,
           'capture_on_share_code': capture_on_share_code,
           'dicom_only': dicom_only,
           'dicom_tag': dicom_tag,
           'dicom_tag_ignore_empty': dicom_tag_ignore_empty,
           'display_order': display_order,
           'field_flag': field_flag,
           'hl7_component': hl7_component,
           'hl7_field': hl7_field,
           'hl7_segment': hl7_segment,
           'load_dicom_tag': load_dicom_tag,
           'load_from_sr': load_from_sr,
           'load_hl7': load_hl7,
           'load_hl7_filter': load_hl7_filter,
           'load_order': load_order,
           'name': name,
           'options': options,
           'other_customfield_id': other_customfield_id,
           'other_customfield_no_overwrite_with_blank': other_customfield_no_overwrite_with_blank,
           'other_customfield_no_refresh_on_reshare': other_customfield_no_refresh_on_reshare,
           'other_dicom_tags': other_dicom_tags,
           'required': required,
           'uuid': uuid,
           'wrapped_dicom_only': wrapped_dicom_only,
        }
	
        errors_mapping = {}
        errors_mapping[('INVALID_DICOM_TAG', None)] = InvalidDicomTag('The DICOM tag is invalid')
        errors_mapping[('INVALID_DICOM_TAG_OBJECT', None)] = InvalidDicomTagObject('DICOM tags can only be applied to study fields')
        errors_mapping[('INVALID_FLAG', None)] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping[('INVALID_HL7_FIELD', None)] = InvalidHl7Field('Invalid field number')
        errors_mapping[('INVALID_HL7_OBJECT', None)] = InvalidHl7Object('HL7 fields can only be applied to study fields')
        errors_mapping[('INVALID_HL7_SEGMENT', None)] = InvalidHl7Segment('Invalid segment name')
        errors_mapping[('INVALID_INTEGER', None)] = InvalidInteger('Invalid integer. The error_subtype holds the invalid integer.')
        errors_mapping[('INVALID_JSON', None)] = InvalidJson('The field is not in valid JSON format. The error_subtype holds the name of the field')
        errors_mapping[('INVALID_OPTIONS', None)] = InvalidOptions('An option is invalid. The error_subtype holds the specific error message')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The object was not found. The error_subtype holds the name of the key for the object that can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to edit the customfield')
        errors_mapping[('NO_DICOM_TAG_DEFINED', None)] = NoDicomTagDefined('The load_dicom_tag flag is set but the dicom_tag field is not defined')
        query_data = {
            'api': self._api,
            'url': '/customfield/set',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def get(
        self,
        uuid,
    ):
        """Get.

        :param uuid: uuid of the customfield
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to view the customfield')
        query_data = {
            'api': self._api,
            'url': '/customfield/get',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def delete(
        self,
        uuid,
    ):
        """Delete.

        :param uuid: uuid of the customfield
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to delete the customfield')
        query_data = {
            'api': self._api,
            'url': '/customfield/delete',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def lookup(
        self,
        account_id,
        name,
    ):
        """Lookup.

        :param account_id: uuid of the account
        :param name: Name of the customfield
        """
        request_data = {
           'account_id': account_id,
           'name': name,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/lookup',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def search(
        self,
        uuid,
        search=None,
    ):
        """Search.

        :param uuid: uuid of the customfield
        :param search: The value to search for (optional)
        """
        request_data = {
           'search': search,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_A_SEARCH', None)] = NotASearch('This is not a search type of customfield')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/search',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def mapping_add(
        self,
        from_customfield_id,
        to_customfield_id,
        overwrite_with_blank=None,
        refresh_on_edit=None,
        refresh_on_reshare=None,
        reverse_refresh_on_edit=None,
    ):
        """Mapping add.

        :param from_customfield_id: The source custom field id
        :param to_customfield_id: The destination custom field id
        :param overwrite_with_blank: Flag if the destination customfield should be updated with a blank value, 1 by default (optional)
        :param refresh_on_edit: Flag if the destination customfield should be updated on the source customfield edit, 1 by default (optional)
        :param refresh_on_reshare: Flag if the destination customfield should be updated on Study reshare, 1 by default (optional)
        :param reverse_refresh_on_edit: Flag if the mapping should apply in reverse, ie to the customfield designated as a from_customfield_id of the original study when a shared version of the study is edited, 0 by default (optional)
        """
        request_data = {
           'from_customfield_id': from_customfield_id,
           'overwrite_with_blank': overwrite_with_blank,
           'refresh_on_edit': refresh_on_edit,
           'refresh_on_reshare': refresh_on_reshare,
           'reverse_refresh_on_edit': reverse_refresh_on_edit,
           'to_customfield_id': to_customfield_id,
        }
	
        errors_mapping = {}
        errors_mapping[('ALREADY_EXISTS', None)] = AlreadyExists('The mapping rule already exists')
        errors_mapping[('INVALID_FLAG', None)] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield can not be found, The error_subtype refers to a customfield by the following values: FROM_CUSTOMFIELD or TO_CUSTOMFIELD')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/mapping/add',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def mapping_set(
        self,
        uuid,
        overwrite_with_blank=None,
        refresh_on_edit=None,
        refresh_on_reshare=None,
        reverse_refresh_on_edit=None,
    ):
        """Mapping set.

        :param uuid: uuid of the customfield mapping rule
        :param overwrite_with_blank: Flag if the destination customfield should be updated with a blank value, 1 by default (optional)
        :param refresh_on_edit: Flag if the destination customfield should be updated on the source customfield edit, 1 by default (optional)
        :param refresh_on_reshare: Flag if the destination customfield should be updated on Study reshare, 1 by default (optional)
        :param reverse_refresh_on_edit: Flag if the mapping should apply in reverse, ie to the customfield designated as a from_customfield_id of the original study when a shared version of the study is edited, 0 by default (optional)
        """
        request_data = {
           'overwrite_with_blank': overwrite_with_blank,
           'refresh_on_edit': refresh_on_edit,
           'refresh_on_reshare': refresh_on_reshare,
           'reverse_refresh_on_edit': reverse_refresh_on_edit,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('INVALID_FLAG', None)] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield mapping rule can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/mapping/set',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
    def mapping_delete(
        self,
        uuid,
    ):
        """Mapping delete.

        :param uuid: uuid of the customfield mapping rule
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping[('MISSING_FIELDS', None)] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping[('NOT_FOUND', None)] = NotFound('The customfield mapping rule can not be found')
        errors_mapping[('NOT_PERMITTED', None)] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/customfield/mapping/delete',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return AsyncQueryO(**query_data)
    
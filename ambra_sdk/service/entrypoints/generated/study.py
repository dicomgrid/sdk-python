""" Study.

Do not edit this file by hand.
This is generated by parsing api.html service doc.
"""
from ambra_sdk.exceptions.service import Already
from ambra_sdk.exceptions.service import AlreadyExists
from ambra_sdk.exceptions.service import AlreadyThin
from ambra_sdk.exceptions.service import Blocked
from ambra_sdk.exceptions.service import DelayOrMatch
from ambra_sdk.exceptions.service import DestinationNotFound
from ambra_sdk.exceptions.service import Failed
from ambra_sdk.exceptions.service import FilterNotFound
from ambra_sdk.exceptions.service import InProcess
from ambra_sdk.exceptions.service import InvalidAction
from ambra_sdk.exceptions.service import InvalidCondition
from ambra_sdk.exceptions.service import InvalidCredentials
from ambra_sdk.exceptions.service import InvalidCustomfield
from ambra_sdk.exceptions.service import InvalidDelay
from ambra_sdk.exceptions.service import InvalidEmail
from ambra_sdk.exceptions.service import InvalidField
from ambra_sdk.exceptions.service import InvalidFlag
from ambra_sdk.exceptions.service import InvalidJson
from ambra_sdk.exceptions.service import InvalidNpi
from ambra_sdk.exceptions.service import InvalidParameters
from ambra_sdk.exceptions.service import InvalidPhone
from ambra_sdk.exceptions.service import InvalidSortField
from ambra_sdk.exceptions.service import InvalidSortOrder
from ambra_sdk.exceptions.service import InvalidTag
from ambra_sdk.exceptions.service import InvalidTemplate
from ambra_sdk.exceptions.service import Locked
from ambra_sdk.exceptions.service import MissingFields
from ambra_sdk.exceptions.service import MissingInfo
from ambra_sdk.exceptions.service import NamespaceNotFound
from ambra_sdk.exceptions.service import NoFreshArchive
from ambra_sdk.exceptions.service import NoHl7Support
from ambra_sdk.exceptions.service import NoQueryDestination
from ambra_sdk.exceptions.service import NodeNotSetup
from ambra_sdk.exceptions.service import NotAvailable
from ambra_sdk.exceptions.service import NotEnabled
from ambra_sdk.exceptions.service import NotFound
from ambra_sdk.exceptions.service import NotHash
from ambra_sdk.exceptions.service import NotPermitted
from ambra_sdk.exceptions.service import NotReady
from ambra_sdk.exceptions.service import NotThin
from ambra_sdk.exceptions.service import PdfFailed
from ambra_sdk.exceptions.service import Pending
from ambra_sdk.exceptions.service import PendingMustMatch
from ambra_sdk.exceptions.service import Phantom
from ambra_sdk.exceptions.service import RecentNamespaceSplit
from ambra_sdk.exceptions.service import ReportError
from ambra_sdk.exceptions.service import Retrieve
from ambra_sdk.exceptions.service import RouteNotMatched
from ambra_sdk.exceptions.service import Running
from ambra_sdk.exceptions.service import ShareFailed
from ambra_sdk.exceptions.service import Singleton
from ambra_sdk.exceptions.service import Stale
from ambra_sdk.exceptions.service import StudyNotFound
from ambra_sdk.exceptions.service import UnableToGenerate
from ambra_sdk.exceptions.service import UnableToValidate
from ambra_sdk.service.query import QueryO
from ambra_sdk.service.query import QueryOF
from ambra_sdk.service.query import QueryOP
from ambra_sdk.service.query import QueryOPF
from ambra_sdk.service.query import QueryOPS
from ambra_sdk.service.query import QueryOPSF
from ambra_sdk.service.query import QueryOSF

class Study:
    """Study."""

    def __init__(self, api):
        self._api = api

    
    def add(
        self,
        thin,
        accession_number=None,
        attachment_count=None,
        customfield_param=None,
        destination_ae_title=None,
        image_count=None,
        integration_key=None,
        medical_record_locator=None,
        modality=None,
        node_id=None,
        patient_additional_history=None,
        patient_address=None,
        patient_age=None,
        patient_birth_date=None,
        patient_birth_time=None,
        patient_birthname=None,
        patient_comments=None,
        patient_current_location=None,
        patient_ethnic_group=None,
        patient_institution_residence=None,
        patient_mother_birthname=None,
        patient_name=None,
        patient_name_other=None,
        patient_occupation=None,
        patient_phone=None,
        patient_religious_preference=None,
        patient_sex=None,
        patient_size=None,
        patient_weight=None,
        patientid=None,
        patientid_other=None,
        phi_namespace=None,
        referring_physician=None,
        serial_no=None,
        source_ae_title=None,
        storage_namespace=None,
        study_date=None,
        study_description=None,
        study_time=None,
        study_uid=None,
        uuid=None,
    ):
        """Add.
        :param thin: Flag to add this as a thin study
        :param accession_number: DICOM tag (0008,0050) (optional)
        :param attachment_count: Attachment count (optional)
        :param customfield_param: Custom field(s), see notes in /study/add (optional)
        :param destination_ae_title: The destination aetitle (optional)
        :param image_count: Images in the study (optional)
        :param integration_key: Integration key for the study (optional)
        :param medical_record_locator: DICOM tag (0010,1090) (optional)
        :param modality: DICOM tag (0008,0060) (optional)
        :param node_id: If this is a thin study the gateway UUID to retrieve it from can be specified (optional)
        :param patient_additional_history: DICOM tag (0010,21B0) (optional)
        :param patient_address: DICOM tag (0010,1040) (optional)
        :param patient_age: DICOM tag (0010,1010) (optional)
        :param patient_birth_date: DICOM tag (0010,0030) (optional)
        :param patient_birth_time: DICOM tag (0010,0032) (optional)
        :param patient_birthname: DICOM tag (0010,1005) (optional)
        :param patient_comments: DICOM tag (0010,4000) (optional)
        :param patient_current_location: DICOM tag (0038,0300) (optional)
        :param patient_ethnic_group: DICOM tag (0010,2160) (optional)
        :param patient_institution_residence: DICOM tag (0038,0400) (optional)
        :param patient_mother_birthname: DICOM tag (0010,1060) (optional)
        :param patient_name: DICOM tag (0010,0010)(optional)
        :param patient_name_other: DICOM tag (0010,1001) (optional)
        :param patient_occupation: DICOM tag (0010,2180) (optional)
        :param patient_phone: DICOM tag (0010,2154) (optional)
        :param patient_religious_preference: DICOM tag (0010,21F0) (optional)
        :param patient_sex: DICOM tag (0010,0040) (optional)
        :param patient_size: DICOM tag (0010,1020) (optional)
        :param patient_weight: DICOM tag (0010,1030) (optional)
        :param patientid: DICOM tag (0010,0020) (optional)
        :param patientid_other: DICOM tag (0010,1000) (optional)
        :param phi_namespace: phi_namespace
        :param referring_physician: DICOM tag (0008,0090) (optional)
        :param serial_no: serial_no
        :param source_ae_title: The source aetitle (optional)
        :param storage_namespace: storage_namespace
        :param study_date: DICOM tag (0008,0020) (optional)
        :param study_description: DICOM tag (0008,1030) (optional)
        :param study_time: DICOM tag (0008,0030) (optional)
        :param study_uid: study_uid
        :param uuid: uuid

        Notes:
        (sid OR uuid AND serial_no) - Either the sid or the node id and serial number
        (study_uid OR study_uid AND storage_namespace AND phi_namespace) - The study uid if node authentication or the storage triplet if sid authentication
        customfield-(CUSTOMFIELD_UUID OR DICOM_TAG) - Custom field(s), see notes in /study/add (optional)
        """
        request_data = {
           'patient_age': patient_age,
           'patient_birth_date': patient_birth_date,
           'serial_no': serial_no,
           'node_id': node_id,
           'study_time': study_time,
           'patient_sex': patient_sex,
           'patient_birth_time': patient_birth_time,
           'integration_key': integration_key,
           'patient_mother_birthname': patient_mother_birthname,
           'patientid': patientid,
           'patient_religious_preference': patient_religious_preference,
           'patient_institution_residence': patient_institution_residence,
           'study_uid': study_uid,
           'study_description': study_description,
           'referring_physician': referring_physician,
           'image_count': image_count,
           'medical_record_locator': medical_record_locator,
           'attachment_count': attachment_count,
           'patient_phone': patient_phone,
           'patient_comments': patient_comments,
           'uuid': uuid,
           'accession_number': accession_number,
           'study_date': study_date,
           'phi_namespace': phi_namespace,
           'patient_name_other': patient_name_other,
           'patient_additional_history': patient_additional_history,
           'patient_birthname': patient_birthname,
           'patient_weight': patient_weight,
           'destination_ae_title': destination_ae_title,
           'storage_namespace': storage_namespace,
           'patient_address': patient_address,
           'patient_ethnic_group': patient_ethnic_group,
           'patientid_other': patientid_other,
           'source_ae_title': source_ae_title,
           'patient_name': patient_name,
           'modality': modality,
           'patient_size': patient_size,
           'patient_current_location': patient_current_location,
           'thin': thin,
           'patient_occupation': patient_occupation,
        }
        if customfield_param is not None:
            customfield_param_dict = {'{prefix}{k}'.format(prefix='customfield-', k=k): v for k,v in customfield_param.items()}
            request_data.update(customfield_param_dict)
	
        errors_mapping = {}
        errors_mapping['ALREADY_EXISTS'] = AlreadyExists('The study already exists. The error_subtype holds the uuid of the study and error_data holds the data from the /study/get call')
        errors_mapping['INVALID_CREDENTIALS'] = InvalidCredentials('The sid or node credentials are invalid')
        errors_mapping['INVALID_CUSTOMFIELD'] = InvalidCustomfield('Invalid custom field(s) name or value were passed. The error_subtype holds an array of the error details')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NAMESPACE_NOT_FOUND'] = NamespaceNotFound('The namespace was not found')
        errors_mapping['NOT_FOUND'] = NotFound('The error_subtype holds the name of the key for the object that can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/study/add',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def set(
        self,
        accession_number=None,
        attachment_count=None,
        customfield_param=None,
        destination_ae_title=None,
        find_order_uuid=None,
        image_count=None,
        integration_key=None,
        medical_record_locator=None,
        modality=None,
        node_id=None,
        patient_additional_history=None,
        patient_address=None,
        patient_age=None,
        patient_birth_date=None,
        patient_birth_time=None,
        patient_birthname=None,
        patient_comments=None,
        patient_current_location=None,
        patient_ethnic_group=None,
        patient_institution_residence=None,
        patient_mother_birthname=None,
        patient_name=None,
        patient_name_other=None,
        patient_occupation=None,
        patient_phone=None,
        patient_religious_preference=None,
        patient_sex=None,
        patient_size=None,
        patient_weight=None,
        patientid=None,
        patientid_other=None,
        phi_namespace=None,
        referring_physician=None,
        serial_no=None,
        source_ae_title=None,
        storage_namespace=None,
        study_date=None,
        study_description=None,
        study_id=None,
        study_time=None,
        study_uid=None,
        use_upload_permission=None,
        uuid=None,
    ):
        """Set.
        :param accession_number: DICOM tag (0008,0050) (optional)
        :param attachment_count: Attachment count (optional)
        :param customfield_param: Custom field(s), see notes in /study/add (optional)
        :param destination_ae_title: The destination aetitle (optional)
        :param find_order_uuid: UUID of the search record used to modify the study (optional)
        :param image_count: Images in the study (optional)
        :param integration_key: Integration key for the study (optional)
        :param medical_record_locator: DICOM tag (0010,1090) (optional)
        :param modality: DICOM tag (0008,0060) (optional)
        :param node_id: If this is a thin study the gateway UUID to retrieve it from can be specified (optional)
        :param patient_additional_history: DICOM tag (0010,21B0) (optional)
        :param patient_address: DICOM tag (0010,1040) (optional)
        :param patient_age: DICOM tag (0010,1010) (optional)
        :param patient_birth_date: DICOM tag (0010,0030) (optional)
        :param patient_birth_time: DICOM tag (0010,0032) (optional)
        :param patient_birthname: DICOM tag (0010,1005) (optional)
        :param patient_comments: DICOM tag (0010,4000) (optional)
        :param patient_current_location: DICOM tag (0038,0300) (optional)
        :param patient_ethnic_group: DICOM tag (0010,2160) (optional)
        :param patient_institution_residence: DICOM tag (0038,0400) (optional)
        :param patient_mother_birthname: DICOM tag (0010,1060) (optional)
        :param patient_name: DICOM tag (0010,0010) (optional)
        :param patient_name_other: DICOM tag (0010,1001) (optional)
        :param patient_occupation: DICOM tag (0010,2180) (optional)
        :param patient_phone: DICOM tag (0010,2154) (optional)
        :param patient_religious_preference: DICOM tag (0010,21F0) (optional)
        :param patient_sex: DICOM tag (0010,0040) (optional)
        :param patient_size: DICOM tag (0010,1020) (optional)
        :param patient_weight: DICOM tag (0010,1030) (optional)
        :param patientid: DICOM tag (0010,0020) (optional)
        :param patientid_other: DICOM tag (0010,1000) (optional)
        :param phi_namespace: phi_namespace
        :param referring_physician: DICOM tag (0008,0090) (optional)
        :param serial_no: serial_no
        :param source_ae_title: The source aetitle (optional)
        :param storage_namespace: storage_namespace
        :param study_date: DICOM tag (0008,0020) (optional)
        :param study_description: DICOM tag (0008,1030) (optional)
        :param study_id: study_id
        :param study_time: DICOM tag (0008,0030) (optional)
        :param study_uid: study_uid
        :param use_upload_permission: Flag to use the upload permissions for the permissions check (optional)
        :param uuid: uuid

        Notes:
        (sid OR uuid AND serial_no) - Either the sid or the node id and serial number
        customfield-(CUSTOMFIELD_UUID OR DICOM_TAG) - Custom field(s), see notes in /study/add (optional)
        (study_id OR study_uid OR study_uid AND storage_namespace AND phi_namespace) The uuid of the study if sid authentication or the study_uid if node authentication or the storage triplet if you want a future set
        """
        request_data = {
           'patient_age': patient_age,
           'patient_birth_date': patient_birth_date,
           'serial_no': serial_no,
           'node_id': node_id,
           'study_time': study_time,
           'use_upload_permission': use_upload_permission,
           'find_order_uuid': find_order_uuid,
           'patient_sex': patient_sex,
           'patient_birth_time': patient_birth_time,
           'study_id': study_id,
           'integration_key': integration_key,
           'patient_mother_birthname': patient_mother_birthname,
           'patientid': patientid,
           'patient_religious_preference': patient_religious_preference,
           'patient_institution_residence': patient_institution_residence,
           'study_uid': study_uid,
           'study_description': study_description,
           'referring_physician': referring_physician,
           'image_count': image_count,
           'medical_record_locator': medical_record_locator,
           'attachment_count': attachment_count,
           'patient_phone': patient_phone,
           'patient_comments': patient_comments,
           'uuid': uuid,
           'accession_number': accession_number,
           'study_date': study_date,
           'phi_namespace': phi_namespace,
           'patient_name_other': patient_name_other,
           'patient_additional_history': patient_additional_history,
           'patient_birthname': patient_birthname,
           'patient_weight': patient_weight,
           'destination_ae_title': destination_ae_title,
           'storage_namespace': storage_namespace,
           'patient_address': patient_address,
           'patient_ethnic_group': patient_ethnic_group,
           'patientid_other': patientid_other,
           'source_ae_title': source_ae_title,
           'patient_name': patient_name,
           'modality': modality,
           'patient_size': patient_size,
           'patient_current_location': patient_current_location,
           'patient_occupation': patient_occupation,
        }
        if customfield_param is not None:
            customfield_param_dict = {'{prefix}{k}'.format(prefix='customfield-', k=k): v for k,v in customfield_param.items()}
            request_data.update(customfield_param_dict)
	
        errors_mapping = {}
        errors_mapping['INVALID_CREDENTIALS'] = InvalidCredentials('The sid or node credentials are invalid')
        errors_mapping['INVALID_CUSTOMFIELD'] = InvalidCustomfield('Invalid custom field(s) name or value were passed. The error_subtype holds an array of the error details')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to edit this study')
        errors_mapping['PENDING_MUST_MATCH'] = PendingMustMatch('The study is pending a must match approval from storage and can not be edited in this state')
        query_data = {
            'api': self._api,
            'url': '/study/set',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def delete(
        self,
        node_id=None,
        phi_namespace=None,
        serial_no=None,
        storage_namespace=None,
        study_uid=None,
        uuid=None,
    ):
        """Delete.
        :param node_id: node_id
        :param phi_namespace: phi_namespace
        :param serial_no: serial_no
        :param storage_namespace: storage_namespace
        :param study_uid: study_uid
        :param uuid: uuid

        Notes:
        (sid OR node_id AND serial_no) - Either the sid or the node id and serial number
        (uuid OR study_uid AND storage_namespace AND phi_namespace) - The study uuid or the storage triplet
        """
        request_data = {
           'storage_namespace': storage_namespace,
           'serial_no': serial_no,
           'uuid': uuid,
           'node_id': node_id,
           'study_uid': study_uid,
           'phi_namespace': phi_namespace,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to delete this study')
        query_data = {
            'api': self._api,
            'url': '/study/delete',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def list(
        self,
        customfield_h=None,
        extra=None,
        fields=None,
        permissions_diff=None,
        template=None,
    ):
        """List.
        :param customfield_h: Flag to return a customfield hash as detailed in /study/get (optional)
        :param extra: Flag to return extra data as detailed in /study/get (optional)
        :param fields: A JSON list of the study fields to return (optional)
        :param permissions_diff: Flag to return only the permissions that differ from the namespace permissions (optional)
        :param template: A JSON hash with name, account_id and language of the template to return (optional)
        """
        request_data = {
           'template': template,
           'customfield_h': customfield_h,
           'fields': fields,
           'extra': extra,
           'permissions_diff': permissions_diff,
        }
	
        errors_mapping = {}
        errors_mapping['FILTER_NOT_FOUND'] = FilterNotFound('The filter can not be found. The error_subtype will hold the filter UUID')
        errors_mapping['INVALID_CONDITION'] = InvalidCondition('The condition is not support. The error_subtype will hold the filter expression this applies to')
        errors_mapping['INVALID_FIELD'] = InvalidField('The field is not valid for this object. The error_subtype will hold the filter expression this applies to')
        errors_mapping['INVALID_SORT_FIELD'] = InvalidSortField('The field is not valid for this object. The error_subtype will hold the field name this applies to')
        errors_mapping['INVALID_SORT_ORDER'] = InvalidSortOrder('The sort order for the field is invalid. The error_subtype will hold the field name this applies to')
        errors_mapping['INVALID_TEMPLATE'] = InvalidTemplate('The template is invalid the error_subtype holds the detail')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        query_data = {
            'api': self._api,
            'url': '/study/list',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        query_data['paginated_field'] = 'studies'
        return QueryOPSF(**query_data)
    
    def count(
        self,
    ):
        """Count.
        """
        request_data = {
        }
	
        errors_mapping = {}
        errors_mapping['FILTER_NOT_FOUND'] = FilterNotFound('The filter can not be found. The error_subtype will hold the filter UUID')
        errors_mapping['INVALID_CONDITION'] = InvalidCondition('The condition is not support. The error_subtype will hold the filter expression this applies to')
        errors_mapping['INVALID_FIELD'] = InvalidField('The field is not valid for this object. The error_subtype will hold the filter expression this applies to')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        query_data = {
            'api': self._api,
            'url': '/study/count',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryOF(**query_data)
    
    def cfind(
        self,
        serial_no,
        uuid,
        entire_account=None,
        is_available=None,
    ):
        """Cfind.
        :param serial_no: The serial number of the node
        :param uuid: The node id
        :param entire_account: Flag to search the entire account rather than just the nodes namespace. (optional)
        :param is_available: Flag to limit search to studies that are ready for viewing. (optional)
        """
        request_data = {
           'is_available': is_available,
           'serial_no': serial_no,
           'uuid': uuid,
           'entire_account': entire_account,
        }
	
        errors_mapping = {}
        errors_mapping['FILTER_NOT_FOUND'] = FilterNotFound('The filter can not be found. The error_subtype will hold the filter UUID')
        errors_mapping['INVALID_CONDITION'] = InvalidCondition('The condition is not support. The error_subtype will hold the filter expression this applies to')
        errors_mapping['INVALID_FIELD'] = InvalidField('The field is not valid for this object. The error_subtype will hold the filter expression this applies to')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The node can not be found')
        query_data = {
            'api': self._api,
            'url': '/study/cfind',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': False,
        }
        query_data['paginated_field'] = 'studies'
        return QueryOPF(**query_data)
    
    def get(
        self,
        customfield_h=None,
        extra=None,
        fields=None,
        full_hl7=None,
        node_id=None,
        permissions_diff=None,
        phi_namespace=None,
        serial_no=None,
        storage_namespace=None,
        study_uid=None,
        uuid=None,
    ):
        """Get.
        :param customfield_h: Flag to return a customfield hash as detailed below (optional)
        :param extra: Flag to return extra data as detailed below (optional)
        :param fields: A JSON list of the study fields to return (optional)
        :param full_hl7: Flag to return the full hl7 record instead of just the uuid (optional)
        :param node_id: node_id
        :param permissions_diff: Flag to return only the permissions that differ from the namespace permissions (optional)
        :param phi_namespace: phi_namespace
        :param serial_no: serial_no
        :param storage_namespace: storage_namespace
        :param study_uid: study_uid
        :param uuid: uuid

        Notes:
        (sid OR node_id AND serial_no) - Either the sid or the node uuid and serial number
        (uuid OR study_uid AND storage_namespace AND phi_namespace) - The study uuid or the storage triplet
        """
        request_data = {
           'storage_namespace': storage_namespace,
           'serial_no': serial_no,
           'uuid': uuid,
           'node_id': node_id,
           'customfield_h': customfield_h,
           'study_uid': study_uid,
           'fields': fields,
           'phi_namespace': phi_namespace,
           'extra': extra,
           'full_hl7': full_hl7,
           'permissions_diff': permissions_diff,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to access this study')
        query_data = {
            'api': self._api,
            'url': '/study/get',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def permissions(
        self,
        uuid,
    ):
        """Permissions.
        :param uuid: The study uuid
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to access this study')
        query_data = {
            'api': self._api,
            'url': '/study/permissions',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def push(
        self,
        batch_no,
        destination_id,
        ping,
        uuid,
    ):
        """Push.
        :param batch_no: The batch number if pushing to a CD burner
        :param destination_id: The destination to push it to
        :param ping: Flag to send the ping job back in this call
        :param uuid: The study uuid
        """
        request_data = {
           'destination_id': destination_id,
           'uuid': uuid,
           'batch_no': batch_no,
           'ping': ping,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study or destination can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to push this study')
        errors_mapping['NOT_READY'] = NotReady('The study is not ready for pushing')
        errors_mapping['PENDING'] = Pending('There is already a pending push job')
        query_data = {
            'api': self._api,
            'url': '/study/push',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def push_hl7(
        self,
        destination_id,
        uuid,
        hl7_id=None,
        hl7_template_id=None,
        once=None,
    ):
        """Push hl7.
        :param destination_id: The destination to push it to
        :param uuid: The study uuid
        :param hl7_id: HL7 message to use in the template (optional)
        :param hl7_template_id: The HL7 template to use (optional)
        :param once: Flag that this message should only be sent a maximum of one time (optional)
        """
        request_data = {
           'destination_id': destination_id,
           'hl7_id': hl7_id,
           'uuid': uuid,
           'hl7_template_id': hl7_template_id,
           'once': once,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study, destination, template or hl7 message can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to push this study')
        errors_mapping['NO_HL7_SUPPORT'] = NoHl7Support('The destination doesn&#39;t support HL7')
        query_data = {
            'api': self._api,
            'url': '/study/push/hl7',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def pdf_hl7(
        self,
        hl7_id,
        uuid,
    ):
        """Pdf hl7.
        :param hl7_id: HL7 message to create the PDF report for
        :param uuid: The study uuid
        """
        request_data = {
           'hl7_id': hl7_id,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['NOT_FOUND'] = NotFound('Not found')
        query_data = {
            'api': self._api,
            'url': '/study/pdf/hl7',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def fax_hl7(
        self,
        hl7_id,
        number,
        uuid,
    ):
        """Fax hl7.
        :param hl7_id: HL7 message to create the PDF report for
        :param number: The fax number to send the PDF report to
        :param uuid: The study uuid
        """
        request_data = {
           'hl7_id': hl7_id,
           'uuid': uuid,
           'number': number,
        }
	
        errors_mapping = {}
        errors_mapping['INVALID_PHONE'] = InvalidPhone('The fax number is invalid')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study or HL7 message can not be found')
        errors_mapping['PDF_FAILED'] = PdfFailed('The PDF report failed to generate')
        query_data = {
            'api': self._api,
            'url': '/study/fax/hl7',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def cmove(
        self,
        aetitle,
        ping,
        serial_no,
        study_uid,
        uuid,
        detail=None,
    ):
        """Cmove.
        :param aetitle: The aetitle to send to
        :param ping: Flag to send the ping job back in this call
        :param serial_no: The serial number of the node
        :param study_uid: The study uid
        :param uuid: The node id
        :param detail: Additional detail to send on the /node/ping (optional)
        """
        request_data = {
           'detail': detail,
           'serial_no': serial_no,
           'uuid': uuid,
           'study_uid': study_uid,
           'ping': ping,
           'aetitle': aetitle,
        }
	
        errors_mapping = {}
        errors_mapping['DESTINATION_NOT_FOUND'] = DestinationNotFound('The destination can not be found')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The node can not be found')
        errors_mapping['NOT_READY'] = NotReady('The study is not ready for pushing')
        errors_mapping['PENDING'] = Pending('There is already a pending push job')
        errors_mapping['RETRIEVE'] = Retrieve('A thin study retrieval error. The error_subtype holds further detail')
        errors_mapping['STUDY_NOT_FOUND'] = StudyNotFound('The study can not be found')
        query_data = {
            'api': self._api,
            'url': '/study/cmove',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': False,
        }
        return QueryO(**query_data)
    
    def node_can_remove(
        self,
        serial_no,
        study_uid,
        uuid,
    ):
        """Node can remove.
        :param serial_no: The serial number of the node
        :param study_uid: The study uid
        :param uuid: The node id
        """
        request_data = {
           'study_uid': study_uid,
           'serial_no': serial_no,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The node can not be found')
        errors_mapping['STUDY_NOT_FOUND'] = StudyNotFound('The study can not be found')
        query_data = {
            'api': self._api,
            'url': '/study/node/can/remove',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': False,
        }
        return QueryO(**query_data)
    
    def share_who(
        self,
        uuid,
        type=None,
    ):
        """Share who.
        :param uuid: The study uuid
        :param type: type

        Notes:
        type - Type of objects you want (account OR location OR group OR user)
        """
        request_data = {
           'uuid': uuid,
           'type': type,
        }
	
        errors_mapping = {}
        query_data = {
            'api': self._api,
            'url': '/study/share/who',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def share(
        self,
        account_id=None,
        charge_authorized=None,
        charge_modality=None,
        customfield_param=None,
        email=None,
        group_id=None,
        integration_key=None,
        location_id=None,
        masshiway=None,
        message=None,
        npi=None,
        phi_namespace=None,
        rsna=None,
        share_code=None,
        storage_namespace=None,
        study_uid=None,
        user_id=None,
        uuid=None,
    ):
        """Share.
        :param account_id: account_id
        :param charge_authorized: Flag that the sender authorized charging for this share (optional)
        :param charge_modality: Modality of the study the charge was authorized for (optional)
        :param customfield_param: Custom field(s) to apply to the shared study (optional)
        :param email: email
        :param group_id: group_id
        :param integration_key: Integration key to tag the share with (optional)
        :param location_id: location_id
        :param masshiway: masshiway
        :param message: Message to the recipient (optional)
        :param npi: npi
        :param phi_namespace: phi_namespace
        :param rsna: rsna
        :param share_code: share_code
        :param storage_namespace: storage_namespace
        :param study_uid: study_uid
        :param user_id: user_id
        :param uuid: uuid

        Notes:
        (uuid OR study_uid AND storage_namespace AND phi_namespace) - The study uuid or the storage triplet if you want a future share
        (account_id OR location_id OR group_id OR user_id OR share_code OR email OR masshiway OR rsna OR npi) - uuid of the account, location, group, user or share code, email address(es), RSNA, NPI or masshiway recipient to share this study with
        """
        request_data = {
           'group_id': group_id,
           'integration_key': integration_key,
           'account_id': account_id,
           'study_uid': study_uid,
           'charge_modality': charge_modality,
           'message': message,
           'charge_authorized': charge_authorized,
           'email': email,
           'uuid': uuid,
           'phi_namespace': phi_namespace,
           'masshiway': masshiway,
           'storage_namespace': storage_namespace,
           'npi': npi,
           'location_id': location_id,
           'user_id': user_id,
           'rsna': rsna,
           'share_code': share_code,
        }
        if customfield_param is not None:
            customfield_param_dict = {'{prefix}{k}'.format(prefix='customfield-', k=k): v for k,v in customfield_param.items()}
            request_data.update(customfield_param_dict)
	
        errors_mapping = {}
        errors_mapping['INVALID_EMAIL'] = InvalidEmail('An invalid email was passed for an email share')
        errors_mapping['INVALID_JSON'] = InvalidJson('The field is not in valid JSON format. The error_subtype holds the name of the field')
        errors_mapping['INVALID_NPI'] = InvalidNpi('An invalid NPI was passed for a NPI share')
        errors_mapping['INVALID_PARAMETERS'] = InvalidParameters('Only pass a account_id or a location_id or a group_id or a user_id or a share code or an email')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study or share object can not be found. The error_subtype holds a the name of the key that can not be found')
        errors_mapping['NOT_HASH'] = NotHash('The field is not a JSON hash. The error_subtype holds the name of the field')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to share this study')
        errors_mapping['PHANTOM'] = Phantom('This is a phantom study')
        errors_mapping['SHARE_FAILED'] = ShareFailed('The share failed. The error_subtype holds one of the following conditions.')
        query_data = {
            'api': self._api,
            'url': '/study/share',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def share_stop(
        self,
        uuid,
        account_id=None,
        group_id=None,
        location_id=None,
        user_id=None,
        user_invite_share_id=None,
    ):
        """Share stop.
        :param uuid: The study uuid
        :param account_id: account_id
        :param group_id: group_id
        :param location_id: location_id
        :param user_id: user_id
        :param user_invite_share_id: user_invite_share_id

        Notes:
        (account_id OR location_id OR group_id OR user_id OR user_invite_share_id) - uuid of the account, location, group, user or user invitation to stop sharing this study with
        """
        request_data = {
           'group_id': group_id,
           'uuid': uuid,
           'location_id': location_id,
           'user_id': user_id,
           'user_invite_share_id': user_invite_share_id,
           'account_id': account_id,
        }
	
        errors_mapping = {}
        errors_mapping['INVALID_PARAMETERS'] = InvalidParameters('Only pass a account_id or a location_id or a group_id or a user_id')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study or share object can not be found. The error_subtype holds a the name of the key that can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to stop sharing this study')
        query_data = {
            'api': self._api,
            'url': '/study/share/stop',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def share_list(
        self,
        uuid,
        name=None,
    ):
        """Share list.
        :param uuid: The study uuid
        :param name: Flag to return a hash with both the uuid and name of the object (optional)
        """
        request_data = {
           'uuid': uuid,
           'name': name,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to view this list')
        query_data = {
            'api': self._api,
            'url': '/study/share/list',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def approve(
        self,
        uuid,
        delay=None,
        must_match=None,
    ):
        """Approve.
        :param uuid: The study uuid
        :param delay: Number of seconds to delay showing the study as approved and running routing and events on it (optional)
        :param must_match: A JSON hash of study field names and values that must match before showing the study as approved and running routing and events on it (optional)
        """
        request_data = {
           'must_match': must_match,
           'uuid': uuid,
           'delay': delay,
        }
	
        errors_mapping = {}
        errors_mapping['DELAY_OR_MATCH'] = DelayOrMatch('You can either delay or match, not both')
        errors_mapping['INVALID_DELAY'] = InvalidDelay('A delay must be between 0 and 600 seconds')
        errors_mapping['INVALID_FIELD'] = InvalidField('An invalid must match field was passed. The error_subtype holds the name of the field')
        errors_mapping['INVALID_JSON'] = InvalidJson('The field is not in valid JSON format. The error_subtype holds the name of the field')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to approve this study')
        query_data = {
            'api': self._api,
            'url': '/study/approve',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def reject(
        self,
        uuid,
        message=None,
    ):
        """Reject.
        :param uuid: The study uuid
        :param message: Message to send to the person who shared the study (optional)
        """
        request_data = {
           'uuid': uuid,
           'message': message,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to approve this study')
        query_data = {
            'api': self._api,
            'url': '/study/reject',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def audit(
        self,
        detail,
        action=None,
        phi_namespace=None,
        storage_namespace=None,
        study_uid=None,
        uuid=None,
    ):
        """Audit.
        :param detail: Additional information
        :param action: action
        :param phi_namespace: The phi namespace of the study (optional)
        :param storage_namespace: The storage namespace of the study (optional if uuid is passed)
        :param study_uid: The v3 storage uid of the study (optional if uuid is passed)
        :param uuid: The id of the study (optional if study_uid and storage_namespace are passed)

        Notes:
        action - The audit action (STUDY_VIEW OR STUDY_EDIT OR REPORT_UPLOAD OR REPORT_VIEW OR IMAGE_ADDED OR IMAGE_UPDATED OR STUDY_DOWNLOAD OR ACCEPTED_NOT_DIAGNOSTIC OR CANCELED_NOT_DIAGNOSTIC OR AI_ACTION OR VIEWER_ACTION)
        """
        request_data = {
           'action': action,
           'storage_namespace': storage_namespace,
           'detail': detail,
           'uuid': uuid,
           'study_uid': study_uid,
           'phi_namespace': phi_namespace,
        }
	
        errors_mapping = {}
        errors_mapping['INVALID_ACTION'] = InvalidAction('An invalid action was passed')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        query_data = {
            'api': self._api,
            'url': '/study/audit',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def star(
        self,
        uuid,
        star=None,
    ):
        """Star.
        :param uuid: The id of the study
        :param star: star

        Notes:
        star - Star flag set on or off (1 OR 0)
        """
        request_data = {
           'uuid': uuid,
           'star': star,
        }
	
        errors_mapping = {}
        errors_mapping['INVALID_FLAG'] = InvalidFlag('An invalid flag was passed. The error_subtype holds the name of the invalid flag')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to star this study')
        query_data = {
            'api': self._api,
            'url': '/study/star',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def report_detail(
        self,
        account_id,
        limit=None,
    ):
        """Report detail.
        :param account_id: Limit to studies in the passed account
        :param limit: Maximum size of the report. The default is 30,000 rows. If the report will be bigger than this an error will be returned (optional)
        """
        request_data = {
           'limit': limit,
           'account_id': account_id,
        }
	
        errors_mapping = {}
        errors_mapping['FILTER_NOT_FOUND'] = FilterNotFound('The filter can not be found. The error_subtype will hold the filter UUID')
        errors_mapping['INVALID_CONDITION'] = InvalidCondition('The condition is not support. The error_subtype will hold the filter expression this applies to')
        errors_mapping['INVALID_FIELD'] = InvalidField('The field is not valid for this object. The error_subtype will hold the filter expression this applies to')
        errors_mapping['INVALID_SORT_FIELD'] = InvalidSortField('The field is not valid for this object. The error_subtype will hold the field name this applies to')
        errors_mapping['INVALID_SORT_ORDER'] = InvalidSortOrder('The sort order for the field is invalid. The error_subtype will hold the field name this applies to')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['REPORT_ERROR'] = ReportError('Unable to start the report')
        query_data = {
            'api': self._api,
            'url': '/study/report/detail',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryOSF(**query_data)
    
    def report_series(
        self,
        email,
        hours,
        namespace_id,
        limit=None,
    ):
        """Report series.
        :param email: Send the report to this email address(es) when it is done
        :param hours: Report on studies acquired within the last number of hours
        :param namespace_id: Namespace to run the report on
        :param limit: Maximum size of the report. The default is 30,000 studies. If the report will be bigger than this an error will be returned (optional)
        """
        request_data = {
           'limit': limit,
           'hours': hours,
           'email': email,
           'namespace_id': namespace_id,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['REPORT_ERROR'] = ReportError('Unable to start the report')
        query_data = {
            'api': self._api,
            'url': '/study/report/series',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def viewer_settings(
        self,
        phi_namespace=None,
        storage_namespace=None,
        study_id=None,
        study_uid=None,
    ):
        """Viewer settings.
        :param phi_namespace: phi_namespace
        :param storage_namespace: storage_namespace
        :param study_id: study_id
        :param study_uid: study_uid

        Notes:
        (study_id OR study_uid AND storage_namespace AND phi_namespace) - Either the study uuid or the storage triplet
        """
        request_data = {
           'study_id': study_id,
           'storage_namespace': storage_namespace,
           'study_uid': study_uid,
           'phi_namespace': phi_namespace,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        query_data = {
            'api': self._api,
            'url': '/study/viewer/settings',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def viewer3_settings(
        self,
        phi_namespace=None,
        settings=None,
        storage_namespace=None,
        study_id=None,
        study_uid=None,
    ):
        """Viewer3 settings.
        :param phi_namespace: phi_namespace
        :param settings: A JSON list of user settings set via /setting/set to return (optional)
        :param storage_namespace: storage_namespace
        :param study_id: study_id
        :param study_uid: study_uid

        Notes:
        (study_id OR study_uid AND storage_namespace AND phi_namespace) - Either the study uuid or the storage triplet
        """
        request_data = {
           'study_id': study_id,
           'storage_namespace': storage_namespace,
           'study_uid': study_uid,
           'settings': settings,
           'phi_namespace': phi_namespace,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        query_data = {
            'api': self._api,
            'url': '/study/viewer3/settings',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def status_set(
        self,
        new,
        old,
        study_id,
    ):
        """Status set.
        :param new: The new study status value
        :param old: The old study status value
        :param study_id: Study uuid
        """
        request_data = {
           'study_id': study_id,
           'new': new,
           'old': old,
        }
	
        errors_mapping = {}
        errors_mapping['INVALID_TAG'] = InvalidTag('The study status new value is not a valid value')
        errors_mapping['LOCKED'] = Locked('Another user has locked this study')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to set the status for this study')
        errors_mapping['SINGLETON'] = Singleton('The stage is a singleton stage and the user already has a locked study')
        errors_mapping['STALE'] = Stale('The study status you have is stale')
        query_data = {
            'api': self._api,
            'url': '/study/status/set',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def status_locks(
        self,
    ):
        """Status locks.
        """
        request_data = {
        }
	
        errors_mapping = {}
        query_data = {
            'api': self._api,
            'url': '/study/status/locks',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        query_data['paginated_field'] = 'studies'
        return QueryOP(**query_data)
    
    def status_history(
        self,
        study_id,
    ):
        """Status history.
        :param study_id: Study uuid
        """
        request_data = {
           'study_id': study_id,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to view the status for this study')
        query_data = {
            'api': self._api,
            'url': '/study/status/history',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def move(
        self,
        namespace_id,
        uuid,
    ):
        """Move.
        :param namespace_id: The namespace id
        :param uuid: The study id
        """
        request_data = {
           'uuid': uuid,
           'namespace_id': namespace_id,
        }
	
        errors_mapping = {}
        errors_mapping['ALREADY_EXISTS'] = AlreadyExists('The study already exists in the destination namespace')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study or namespace was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to move the study to this namespace')
        query_data = {
            'api': self._api,
            'url': '/study/move',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def duplicate(
        self,
        include_attachments,
        namespace_id,
        uuid,
    ):
        """Duplicate.
        :param include_attachments: Also duplicate attachments
        :param namespace_id: The namespace id to duplicate it to
        :param uuid: The study id
        """
        request_data = {
           'uuid': uuid,
           'namespace_id': namespace_id,
           'include_attachments': include_attachments,
        }
	
        errors_mapping = {}
        errors_mapping['ALREADY_EXISTS'] = AlreadyExists('The study already exists in the destination namespace')
        errors_mapping['FAILED'] = Failed('The storage call failed to run')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study or namespace was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to duplicate the study to this namespace')
        query_data = {
            'api': self._api,
            'url': '/study/duplicate',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def split(
        self,
        namespace_id,
        no_split,
        uuid,
    ):
        """Split.
        :param namespace_id: The namespace id to split it into
        :param no_split: Do not split on the series just create a new study with a study UID
        :param uuid: The study id
        """
        request_data = {
           'uuid': uuid,
           'namespace_id': namespace_id,
           'no_split': no_split,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_AVAILABLE'] = NotAvailable('The study is not available.')
        errors_mapping['NOT_FOUND'] = NotFound('The study or namespace was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to split the study to this namespace')
        errors_mapping['RECENT_NAMESPACE_SPLIT'] = RecentNamespaceSplit('The study was the result of a split in this namespace within the last 24 hours')
        errors_mapping['RUNNING'] = Running('The split job is currently running')
        query_data = {
            'api': self._api,
            'url': '/study/split',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def freeze(
        self,
        thaw,
        uuid,
    ):
        """Freeze.
        :param thaw: Flag to thaw a frozen study
        :param uuid: The study id
        """
        request_data = {
           'thaw': thaw,
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['ALREADY'] = Already('The study is already frozen or thawed')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_AVAILABLE'] = NotAvailable('The study is not available.')
        errors_mapping['NOT_FOUND'] = NotFound('The study')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to freeze or thaw the study')
        query_data = {
            'api': self._api,
            'url': '/study/freeze',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def manual_route(
        self,
        route_id,
        uuid,
        email=None,
        message=None,
    ):
        """Manual route.
        :param route_id: The routing rule id
        :param uuid: The study id
        :param email: The email to share with if the rule has a share_email action with the USER_ENTRY token (optional)
        :param message: The share message for the email share (optional)
        """
        request_data = {
           'uuid': uuid,
           'message': message,
           'route_id': route_id,
           'email': email,
        }
	
        errors_mapping = {}
        errors_mapping['INVALID_EMAIL'] = InvalidEmail('An invalid email address was passed')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study or routing rule was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to manually route the study')
        errors_mapping['ROUTE_NOT_MATCHED'] = RouteNotMatched('The study does not match the route criteria')
        query_data = {
            'api': self._api,
            'url': '/study/manual/route',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def find_order(
        self,
        uuid,
        accession_number=None,
        patient_name=None,
        patientid=None,
    ):
        """Find order.
        :param uuid: The study id
        :param accession_number: accession_number
        :param patient_name: patient_name
        :param patientid: patientid

        Notes:
        (accession_number OR patientid OR patient_name) - The full or partial accession number, MRN or patient name to search by. If none are passed the studies accession number will be used (optional)
        """
        request_data = {
           'patientid': patientid,
           'uuid': uuid,
           'accession_number': accession_number,
           'patient_name': patient_name,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to find orders for this study')
        query_data = {
            'api': self._api,
            'url': '/study/find/order',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        query_data['paginated_field'] = 'orders'
        return QueryOP(**query_data)
    
    def archive(
        self,
        uuid,
    ):
        """Archive.
        :param uuid: The study id
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['ALREADY_THIN'] = AlreadyThin('This is already a thin study')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        errors_mapping['NO_FRESH_ARCHIVE'] = NoFreshArchive('A fresh archive copy of the study does not exist')
        query_data = {
            'api': self._api,
            'url': '/study/archive',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def retrieve(
        self,
        uuid,
    ):
        """Retrieve.
        :param uuid: The study id
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['MISSING_INFO'] = MissingInfo('The study needs a study_uid and an accession number')
        errors_mapping['NOT_FOUND'] = NotFound('The study was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        errors_mapping['NOT_THIN'] = NotThin('This is not a thin study')
        errors_mapping['NO_QUERY_DESTINATION'] = NoQueryDestination('No query retrieve destination for a node that creates phantoms is available')
        query_data = {
            'api': self._api,
            'url': '/study/retrieve',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def comment_add(
        self,
        body,
        study_id,
    ):
        """Comment add.
        :param body: The comment body
        :param study_id: The study id
        """
        request_data = {
           'study_id': study_id,
           'body': body,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/study/comment/add',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def comment_delete(
        self,
        uuid,
    ):
        """Comment delete.
        :param uuid: The comment id
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The comment was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/study/comment/delete',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def comment_get(
        self,
        uuid,
    ):
        """Comment get.
        :param uuid: The comment id
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The comment was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/study/comment/get',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def validate(
        self,
        uuid,
        validate_id,
        series=None,
    ):
        """Validate.
        :param uuid: The study id
        :param validate_id: The validation id
        :param series: Only validate the specified series (optional)
        """
        request_data = {
           'series': series,
           'uuid': uuid,
           'validate_id': validate_id,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study or validation was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        errors_mapping['UNABLE_TO_VALIDATE'] = UnableToValidate('The study is not available or did not return the data needed to validate')
        query_data = {
            'api': self._api,
            'url': '/study/validate',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def attach_customfields(
        self,
        uuid,
        report_name=None,
    ):
        """Attach customfields.
        :param uuid: The study id
        :param report_name: The report name (optional defaults to customfields.txt)
        """
        request_data = {
           'uuid': uuid,
           'report_name': report_name,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_AVAILABLE'] = NotAvailable('The study is available')
        errors_mapping['NOT_FOUND'] = NotFound('The study was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/study/attach/customfields',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def external_viewer(
        self,
        redirect,
        uuid,
    ):
        """External viewer.
        :param redirect: A flag to return an HTTP redirect to the viewer URL rather than the JSON structure
        :param uuid: The study id
        """
        request_data = {
           'uuid': uuid,
           'redirect': redirect,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_AVAILABLE'] = NotAvailable('The study is not available')
        errors_mapping['NOT_FOUND'] = NotFound('The study was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        errors_mapping['UNABLE_TO_GENERATE'] = UnableToGenerate('The link could not be successfully generated')
        query_data = {
            'api': self._api,
            'url': '/study/external/viewer',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def question(
        self,
        detail,
        question,
        uuid,
    ):
        """Question.
        :param detail: Optional detail to pass through to the AI stack
        :param question: The question to ask or a JSON array of questions to ask
        :param uuid: The study id
        """
        request_data = {
           'detail': detail,
           'uuid': uuid,
           'question': question,
        }
	
        errors_mapping = {}
        errors_mapping['IN_PROCESS'] = InProcess('The question is currently in process')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NODE_NOT_SETUP'] = NodeNotSetup('A node needs to be attached to the study namespace for this question')
        errors_mapping['NOT_ENABLED'] = NotEnabled('The account does not have the ai_QUESTION customfield')
        errors_mapping['NOT_FOUND'] = NotFound('The study or question was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/study/question',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def dicomdata_load(
        self,
        uuid,
    ):
        """Dicomdata load.
        :param uuid: The study id
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_AVAILABLE'] = NotAvailable('The study is not available in storage')
        errors_mapping['NOT_FOUND'] = NotFound('The study or question was not found.')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        errors_mapping['RUNNING'] = Running('A load job is already running')
        query_data = {
            'api': self._api,
            'url': '/study/dicomdata/load',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def timing_event(
        self,
        event,
        storage_namespace,
        study_uid,
        node_id=None,
        serial_no=None,
        size=None,
    ):
        """Timing event.
        :param event: The event
        :param storage_namespace: The storage namespace
        :param study_uid: The study uid
        :param node_id: node_id
        :param serial_no: serial_no
        :param size: The number of bytes associated with the event (optional)

        Notes:
        (sid OR node_id AND serial_no) - Either the sid or the node uuid and serial number
        """
        request_data = {
           'storage_namespace': storage_namespace,
           'serial_no': serial_no,
           'node_id': node_id,
           'study_uid': study_uid,
           'event': event,
           'size': size,
        }
	
        errors_mapping = {}
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/study/timing/event',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    
    def timing_log(
        self,
        uuid,
    ):
        """Timing log.
        :param uuid: The study uuid
        """
        request_data = {
           'uuid': uuid,
        }
	
        errors_mapping = {}
        errors_mapping['INVALID_SORT_FIELD'] = InvalidSortField('The field is not valid for this object. The error_subtype will hold the field name this applies to')
        errors_mapping['INVALID_SORT_ORDER'] = InvalidSortOrder('The sort order for the field is invalid. The error_subtype will hold the field name this applies to')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to do this')
        query_data = {
            'api': self._api,
            'url': '/study/timing/log',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        query_data['paginated_field'] = 'events'
        return QueryOPS(**query_data)
    
    def sync(
        self,
        image_count=None,
        node_id=None,
        phi_namespace=None,
        serial_no=None,
        storage_namespace=None,
        study_id=None,
        study_uid=None,
    ):
        """Sync.
        :param image_count: Update the study image count and then sync (optional)
        :param node_id: node_id
        :param phi_namespace: phi_namespace
        :param serial_no: serial_no
        :param storage_namespace: storage_namespace
        :param study_id: study_id
        :param study_uid: study_uid

        Notes:
        (sid OR node_id AND serial_no) - Either the sid or the node id and serial number
        (study_id OR study_uid AND storage_namespace AND phi_namespace) - The study id or the study_uid/storage_namespace/phi_namespace triplet
        """
        request_data = {
           'study_id': study_id,
           'storage_namespace': storage_namespace,
           'serial_no': serial_no,
           'node_id': node_id,
           'study_uid': study_uid,
           'phi_namespace': phi_namespace,
           'image_count': image_count,
        }
	
        errors_mapping = {}
        errors_mapping['BLOCKED'] = Blocked('This is a repeat sync which is not allowed')
        errors_mapping['MISSING_FIELDS'] = MissingFields('A required field is missing or does not have data in it. The error_subtype holds a array of all the missing fields')
        errors_mapping['NOT_FOUND'] = NotFound('The study can not be found')
        errors_mapping['NOT_PERMITTED'] = NotPermitted('You are not permitted to sync this study')
        query_data = {
            'api': self._api,
            'url': '/study/sync',
            'request_data': request_data,
            'errors_mapping': errors_mapping,
            'required_sid': True,
        }
        return QueryO(**query_data)
    